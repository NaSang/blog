## 快速排序
### 描述
例如，`5，8，1，3，6，2，4，7`
~~~
1. 以首元素`5`为划分标准，从后往前找第一个比首元素小的，`4`，
从前往后找第一个比首元素大的，`8`，找到这两个元素进行交换；
~~~
`5，*8*，1，3，6，2，*4*，7`

`5，*4*，1，3，6，2，*8*，7`
~~~
2. 继续往前找第一个比首元素小的，往后找第一个比首元素大的，直到二者相邻；
~~~
`5，4，1，3，*6*，*2*，8，7`

`5，4，1，3，*2*，*6*，8，7`
~~~
3. 至此，2及之前都是比5小的，6及之后都是比5大的，所以2的位置，就是5应该排的位置；
因此，交换2和5。
~~~
`*5*，4，1，3，*2*，6，8，7`

`*2*，4，1，3，*5*，6，8，7`
~~~
4. 这样，以5为划分，变成前后两个子问题，继续使用快速排序算法。
~~~

## 二分归并排序
### 描述
例如，`5，8，1，3，6，2，4，7`
~~~
1. 从中间划分，变成两个子问题，分别排序；
~~~
`5，8，1，3，| 6，2，4，7`

`1，3，5，8，| 2，4，6，7`
~~~
2. 不断比较两个数组的首元素，将其中较小者取出；
~~~
①  

`*1*，3，5，8，| 2，4，6，7`

   `     3，5，8，| 2，4，6，7`

   `*1*`
   
②

`3，5，8，| *2*，4，6，7`

   `3，5，8，|      4，6，7`

   `*1*，*2*`
   
   ...
   
~~~
3. 直到其中一个数组为空，将另一个数组剩余的所有元素接在后面即可。
~~~

### 时间复杂度
| 算法 | 最坏情况下 | 平均情况下 |
| ------ | ------ | ------ |
| 插入 | O(n^2) |  O(n^2) |
| 冒泡 | O(n^2) |  O(n^2) |
| 快速 | O(n^2) |  O(nlogn) |
| 堆 |  O(nlogn) |  O(nlogn) |
| 二分归并 |  O(nlogn) |  O(nlogn) |
